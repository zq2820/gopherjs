package build

import (
	"fmt"
	"go/ast"
	"os"
	"os/exec"
	"path"
	"time"

	"github.com/gopherjs/gopherjs/es"
)

type meta struct {
	importName string
	asName     string
	container  string
	method     es.ImportMethod
}

var nodeModules = make(map[string][]*meta)
var libs = NewStringSet()
var hasNewLib = false
var pid *exec.Cmd

func findMeta(lib, importName, asName string, method es.ImportMethod) bool {
	for _, _meta := range nodeModules[lib] {
		if _meta.importName == importName && _meta.asName == asName && _meta.method == method {
			return true
		}
	}
	return false
}

var ImportMethod = (func() map[string]es.ImportMethod {
	_importMethod := make(map[string]es.ImportMethod)
	_importMethod["DEFAULT"] = es.DEFAULT
	_importMethod["NOT_DEFAULT"] = es.NOT_DEFAULT

	return _importMethod
})()

func InitNodeModuleMap(container string) {
	//TODO: 性能待优化
	for lib, metas := range nodeModules {
		arr := make([]*meta, 0)
		for _, _meta := range metas {
			if _meta.container != container {
				arr = append(arr, _meta)
			}
		}
		nodeModules[lib] = arr
	}
}

func HandleNodeModules(args []ast.Expr, container string) {
	var asName string
	method := es.DEFAULT
	lib := args[0].(*ast.BasicLit).Value
	if !libs.Has(lib) {
		hasNewLib = true
	}
	libs.Add(lib)
	importName := args[1].(*ast.BasicLit).Value
	importName = importName[1 : len(importName)-1]
	if len(args) > 2 {
		_asName := ""
		_mode := ""
		for _, elt := range args[2].(*ast.CompositeLit).Elts {
			if basic, ok := elt.(*ast.KeyValueExpr).Value.(*ast.BasicLit); ok {
				_asName = basic.Value
			} else if selectorExpr, ok := elt.(*ast.KeyValueExpr).Value.(*ast.SelectorExpr); ok {
				_mode = selectorExpr.Sel.Name
			}
		}
		if _asName != "" {
			asName = _asName[1 : len(_asName)-1]
		}
		if _mode != "" {
			method = ImportMethod[_mode]
		}
	}

	if nodeModules[lib] == nil {
		nodeModules[lib] = make([]*meta, 0)
	}

	if findMeta(lib, importName, asName, method) {
		return
	}

	nodeModules[lib] = append(nodeModules[lib], &meta{
		importName: importName,
		asName:     asName,
		container:  container,
		method:     method,
	})
}

func GenerateNodeModules(projectUrl string, isWatch bool) (ret []string, reload bool) {
	// preload := fmt.Sprintf("// %s\n", time.Now().String())
	preload := ""
	if len(nodeModules) > 0 {
		if !isWatch {
			for lib, metas := range nodeModules {
				for _, _meta := range metas {
					switch _meta.method {
					case es.DEFAULT:
						if _meta.importName == "*" {
							preload += fmt.Sprintf("import * as %s from %s\n", _meta.asName, lib)
						} else {
							preload += fmt.Sprintf("import %s from %s\n", _meta.importName, lib)
						}
					case es.NOT_DEFAULT:
						if _meta.asName != "" {
							preload += fmt.Sprintf("import {%s as %s} from %s\n", _meta.importName, _meta.asName, lib)
						} else {
							preload += fmt.Sprintf("import {%s} from %s\n", _meta.importName, lib)
						}
					}
				}
			}
		}

		preload += "window[\"_node_modules\"] = {}\n"
		for lib, metas := range nodeModules {
			if isWatch {
				preload += fmt.Sprintf("window[\"_node_modules\"][%s] = require(%s)\n", lib, lib)
			} else {
				init := ""
				set := NewStringSet()
				for _, _meta := range metas {
					set.Add(_meta.container)
				}
				for key := range set.value {
					init += fmt.Sprintf("obj[\"%s\"] = {}\n\t", key)
				}
				for _, _meta := range metas {
					name := _meta.importName
					if _meta.asName != "" {
						name = _meta.asName
					}
					init += fmt.Sprintf("obj[\"%s\"][\"%s\"] = %s\n\t", _meta.container, name, name)
				}
				preload += fmt.Sprintf("window[\"_node_modules\"][%s] = (function(){\n\tvar obj = {}\n\t%sreturn obj\n})()\n", lib, init)
			}
		}

		mode := "dev"
		if !isWatch {
			mode = "prod"
		}
		if hasNewLib {
			filename := "vendors~index.dev.inc.js"
			if !isWatch {
				filename = "vendors~index.prod.inc.js"
			}
			ret = append(ret, path.Join(projectUrl, fmt.Sprintf("../packages/dist/%s", filename)))
			exec.Command("bash", "-c", fmt.Sprintf("rm -f %s", ret[0])).Run()
			ret = append(ret, path.Join(projectUrl, fmt.Sprintf("../packages/dist/%s.inc.js", mode)))
			exec.Command("bash", "-c", fmt.Sprintf("rm -f %s", ret[1])).Run()
			hasNewLib = false
			reload = true
		} else {
			ret = append(ret, path.Join(projectUrl, "../packages/dist/vendors~index.dev.inc.js"))
			ret = append(ret, path.Join(projectUrl, "../packages/dist/dev.inc.js"))
			reload = false

			return
		}

		fmt.Println("Webpack is Running...")
		if os.WriteFile(path.Join(projectUrl, "../packages/index.js"), []byte(preload), 0644) == nil {
			if pid == nil {
				pid = &exec.Cmd{
					Path: "/usr/bin/bash",
					Args: []string{"bash", "-c", fmt.Sprintf("cd %s;npm run %s;", path.Join(projectUrl, "../packages"), mode)},
				}
				if isWatch {
					go (func() {
						pid.Run()
					})()
				} else {
					pid.Run()
				}
			}
			if isWatch {
				for {
					_, err := os.ReadFile(path.Join(projectUrl, "../packages/dist/dev.inc.js"))
					if err == nil {
						_, err := os.ReadFile(path.Join(projectUrl, "../packages/dist/vendors~index.dev.inc.js"))
						if err == nil {
							break
						}
					}
					time.Sleep(500 * time.Millisecond)
				}
			}

			fmt.Println("Webpack is finished!")
			return
		}
	}

	return
}
