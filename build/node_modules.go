package build

import (
	"fmt"
	"go/ast"
	"os"
	"os/exec"
	"path"
	"time"

	"github.com/gopherjs/gopherjs/es"
)

type meta struct {
	importName string
	asName     string
	container  string
	method     es.ImportMethod
}

var nodeModules = make(map[string][]*meta)

func findMeta(lib, importName, asName string, method es.ImportMethod) bool {
	for _, _meta := range nodeModules[lib] {
		if _meta.importName == importName && _meta.asName == asName && _meta.method == method {
			return true
		}
	}
	return false
}

var ImportMethod = (func() map[string]es.ImportMethod {
	_importMethod := make(map[string]es.ImportMethod)
	_importMethod["DEFAULT"] = es.DEFAULT
	_importMethod["NOT_DEFAULT"] = es.NOT_DEFAULT

	return _importMethod
})()

func HandleNodeModules(args []ast.Expr, container string) {
	var asName string
	method := es.DEFAULT
	lib := args[0].(*ast.BasicLit).Value
	importName := args[1].(*ast.BasicLit).Value
	if len(args) > 2 {
		_asName := args[2].(*ast.UnaryExpr).X.(*ast.CompositeLit).Elts[0].(*ast.KeyValueExpr).Value.(*ast.BasicLit).Value
		_mode := args[2].(*ast.UnaryExpr).X.(*ast.CompositeLit).Elts[1].(*ast.KeyValueExpr).Value.(*ast.SelectorExpr).Sel.Name
		if _asName != "" {
			asName = _asName[1 : len(_asName)-1]
		}
		if _mode != "" {
			method = ImportMethod[_mode]
		}
	}

	if nodeModules[lib] == nil {
		nodeModules[lib] = make([]*meta, 0)
	}

	if findMeta(lib, importName, asName, method) {
		return
	}

	nodeModules[lib] = append(nodeModules[lib], &meta{
		importName: importName[1 : len(importName)-1],
		asName:     asName,
		container:  container,
		method:     method,
	})
}

func GenerateNodeModules(projectUrl string, isWatch bool) bool {
	preload := ""
	if len(nodeModules) > 0 {
		for lib, metas := range nodeModules {
			for _, _meta := range metas {
				switch _meta.method {
				case es.DEFAULT:
					if _meta.importName == "*" {
						preload += fmt.Sprintf("import * as %s from %s\n", _meta.asName, lib)
					} else {
						preload += fmt.Sprintf("import %s from %s\n", _meta.importName, lib)
					}
				case es.NOT_DEFAULT:
					if _meta.asName != "" {
						preload += fmt.Sprintf("import {%s as %s} from %s\n", _meta.importName, _meta.asName, lib)
					} else {
						preload += fmt.Sprintf("import {%s} from %s\n", _meta.importName, lib)
					}
				}
			}
		}

		for lib, metas := range nodeModules {
			init := ""
			set := NewStringSet()
			for _, _meta := range metas {
				set.Add(_meta.container)
			}
			for key := range set.value {
				init += fmt.Sprintf("obj[\"%s\"] = {}\n\t", key)
			}
			for _, _meta := range metas {
				name := _meta.importName
				if _meta.asName != "" {
					name = _meta.asName
				}
				init += fmt.Sprintf("obj[\"%s\"][\"%s\"] = %s\n\t", _meta.container, name, name)
			}
			preload += fmt.Sprintf("window[%s] = (function(){\n\tvar obj = {}\n\t%sreturn obj\n})()", lib, init)
		}

		mode := "dev"
		if !isWatch {
			mode = "build"
		}

		fmt.Println("Webpack is Running...")
		if os.WriteFile(path.Join(projectUrl, "../packages/index.js"), []byte(preload), 0644) == nil {
			cmd := exec.Cmd{
				Path: "/usr/bin/bash",
				Args: []string{"bash", "-c", fmt.Sprintf("cd %s;npm run %s;", path.Join(projectUrl, "../packages"), mode)},
			}

			if isWatch {
				go (func() {
					cmd.Run()
				})()

				for {
					_, err := os.ReadFile(path.Join(projectUrl, "../packages/dev.inc.js"))
					if err != nil {
						time.Sleep(500 * time.Millisecond)
					} else {
						break
					}
				}
			} else {
				cmd.Run()
			}

			fmt.Println("Webpack is finished!")
			return true
		}
	}

	return false
}
